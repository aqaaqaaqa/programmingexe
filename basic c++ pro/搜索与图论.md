#搜索与图论
##深度优先搜索 
![dfs和bfs](.\photos\dfs和bfs.png "dfs和bfs")
###dfs代码

> dfs在回溯时一定要恢复现场

```c++
void dfs(int u){
    if(u == n){
        for(int i = 0; i < n; i++) printf("%d", path[i]);
        puts(" ");
        return;
    }
    
	for(int i = 1; i < n; i++){
		if(!st[i]){
			path[u] = i;
			str[i] = true;
			dfs(u + 1);
			st[i] = false;
		}
	}
}
```
##宽度优先搜索
###bfs代码
![bfs](.\photos\bfs.png "bfs")
> bfs使用队列进行实现

```c++
int bfs(){
	int hh = 0, tt = 0;//因为后面有个直接入队了所以tt设成0
	q[0] = {0, 0}//入队
	memset(d, -1, sizeof d);//d = -1说明还没有访问过。
	d[0][0] = 0;//第一个已经入队了
	int dx[4] = {-1, 0, 1, 0}, dy[4] = {0 , 1, 0, -1};
	while(hh <= tt){
		auto t = q[hh++ ];//出队先用再加
		for(int i = 0; i < 4; i++){
			int x = t. forst + dx[i], y = t.second + dy[i];
			if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1){
				d[x][y] = d.[t.first][t.second] + 1;
				q[++ tt] = {x, y};//入队先加尾再入
			}
		}
	}
}

```

##树与图的存储
![图的存储](.\photos\图的存储.png "图的存储")
```c++
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。
(1) 邻接矩阵：g[a][b] 存储边a->b
(2) 邻接表：
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;
// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
// 初始化
idx = 0;
memset(h, -1, sizeof h);


```
##树与图的深度优先遍历
```c++
void dfs(int u){
	st[u] = true;
	
	for(int i = h[u]; i != -1; i = ne[i]){
		int j = e[i];
		if(!st[j]) dfs(j);
	}
}

```
##树与图的宽度优先遍历
```c++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}

```
##拓扑排序
> 有环不可能有拓扑序。
> 有向无环图被称为拓扑图。

![拓扑排序](.\photos\拓扑排序.png "拓扑排序")

###代码
```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}

```