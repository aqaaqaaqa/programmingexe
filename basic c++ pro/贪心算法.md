#贪心算法
##区间选点
> 在多个区间当中选点，使得每个区间当中至少有一个点。
![区间选点](.\photos\区间选点.png "区间选点")
```c++
struct range{
	int l, r;
	bool operator < (const Range & w)const{
		return r < w.r;
	}
}range[N];

int main(){
	scanf("%d", &n);
	for(int i = 0; i < n; i++){
		int l, r;
		cin >> l >> r;
		range[i] = {l, r};
	}
	
	sort(range, range + n);
	
	int res = 0, ed = -2e9;//取一个右端点最小值
	
	for(int i = 0; i < n; i++){
		if(range[i].l > ed){
			res++;
			ed = range[i].r;
		}
	}
	
	cout << res;
}
```
##最大不相交区间
> 按照上面那种方法得出的结果就是最大不相交区间数量。
> `ans <= cnt`使用反证法进行证明，当ans会大于cnt时，说明至少有ans个区间不重叠，但是cnt个点已经够覆盖所有的区间了。
![区间选点](.\photos\区间选点.png "区间选点")

##区间分组
![区间分组](.\photos\区间分组.png "区间分组")
利用小根堆来存储右端点最小值。如果他的左端点比所有集合右端点的最小值还要小，那它肯定和所有的区间都有重合。如果比最小值还要大，那么则可以并入到这里面去。
不可能会属于除了最大值那个集合的其它集合，因为是按左端点排序的。

##区间覆盖
![区间覆盖](.\photos\区间覆盖.png "区间覆盖")

##哈夫曼树
![哈夫曼树](.\photos\哈夫曼树.png "哈夫曼树")

> 用小根堆来找最小值
> 

##排序不等式（打水）
![打水](.\photos\打水.png "打水")
##绝对值不等式（货舱选址）
![仓库最短](.\photos\仓库最短.png "仓库最短")
假设是奇数个，直接选最中间的那个仓库最小，偶数个则是选中间洛谷都行。
##推公式（耍杂技的牛）
![牛](.\photos\牛.png "牛")