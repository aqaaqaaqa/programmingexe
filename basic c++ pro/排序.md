#排序

##快速排序

###代码模板

```c++
    void quick_sort (int q[] ,int l ,int r){
    	if(l >= r) return;
    	
    	int i= l - 1,j = r + 1,x=q[ (l + r)>> 1]
    	while(i < j){
    		do i++; while(q[i] < x);
    		do j--; while(q[j] > x);
    		if(i < j) swap(q[i], q[j]);
    	}
    	
    	quick_sort(q ,l ,j);
    	quick_sort(q ,j+1 ,r);
    }
```
###注意点
1. 当设置`x=q[l]`时后面递归参数必须设置成为`quick_sort(q ,l ,j) quick_sort(q ,j+1 ,r);`，`x=q[r]`也是同理，这是因为快速排序在数组一边出现空的时候，会死循环。
2. 可以通过寻找`q[l] q[r] q[(l + r) >> 1]`三者当中最小的那个数并且和`q[l]`交换来加快排序。
3. 还可以在`i++ j--`的过程当中边进行冒泡排序操作，并且设置两个bool变量来说明两边有没有进行冒泡操作，如果哪边没有则说明这一边已经是有序的了。
4. 不稳定。（排序前后相同元素的位置会发生变化，可以给每个元素再加一维让每个元素不同就行）
##归并排序
###过程
![归并过程](.\photos\归并.png "归并过程")
###代码模板
```c++
void merge_sort(int q[], int l, int r){
	if(l >= r) return;
	
	int mid = (l + r) >> 1;
	merge_sort(q, l, mind);
	merge_sort(q, mid + 1, r);
	
	int k = 0, i = l, j = mid + 1;
	
	while(i <= mid && j <= l){
		if(q[i] <= q[j]) temp[k++] = q[i++];
		else temp[k++] = q[j++];
	}
	
	while(i <= mid) temp[k++] = q[i++];
	while(j <= r) temp[k++] = q[j++];
	
	for(int i = 0, j = l ; j <= r ; j++, i++)
    	q[j] = temp[i];
}
```
##p1923 第k个数
###快速选择算法模板
可以在O(N)复杂度内选择出第k小个数
![快速选择](.\photos\快速选择.png "快速选择")
``` c++
	int quick_choose(int l, int r, int k){
		if(l >= r) return q[l];
		int x = q[l], i = l - 1, j = r + 1;
		while(i < j){
			do i++; while(q[i] < x);
			do j--; while(q[j] > x);
			if(i < j) swap(q[i], q[j]);
		}
		int sl = j - l + 1;
		if(k <= sl ) return quick_choose(l, j, k);
		return quick_choose(j + 1, r, k - sl);
	}
```