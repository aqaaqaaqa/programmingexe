#动态规划
求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。这就是DP（动态规划，dynamic programming）。将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。
能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
动态规划时间复杂度一般是状态数量×转移计算量（每个状态枚举的数量）。
##背包问题
![背包问题](.\photos\背包问题.png "背包问题")
###01背包问题
![01背包问题](.\photos\01背包问题.png "01背包问题")
```c++
for(int i = 1; i <= n; i++ )
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
	}
cout << f[n][m];
```
###完全背包问题
![完全背包](.\photos\完全背包.png "完全背包问题")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0;j <= m; j++)
		for(int k = 0; k *v[i] <=j; k++)
			f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);//包含0在内了,不需要在赋值i-1.
```
![完全背包优化](.\photos\完全背包优化.png "完全背包问题优化")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])
	}
```

如果是算最小值则需要把dp数组全部初始化为最大值。
###多重背包问题
> 多重背包问题就是每件物品的数量是有上限的。
![多重背包](.\photos\多重背包.png "多重背包问题")
> $f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k) k = 0, 1, 2, ..., s[i]$

```c++
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= m; j++)
		for(int k = 0; k * v[i] <= j && k <= s[i]; k++)
			f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
```
> 通过二进制优化可以降低复杂度
> 原理:把一个一个遍历单种物品可以拿的数量转化为一堆一堆的拿,来把遍历数量的复杂度从O(s)降到O(logs)
> 等价于把多重背包拆成了物品变多的01背包
```c++
int n, m;
cin >> n >> m;
int cnt = 0;
for(int i = 1; i <= n; i++){
	int a, b, s;
	cin >> a >> b >> s;
	int k = 1;
	while(k <= s){
		cnt++;
		v[cnt] = k * a;
		w[cnt] = k * b;
		k *= 2;
	}
	if(s > 0){
		cnt++;
		v[cnt] = a * s;
		w[cnt] = b * s;
	}
n = cnt;

for(int i = 1; i <= n; i++)
	for(int j = 0; j <=m; j++){
		f[i][j] = f[i - 1][j];
		f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
	}

cout << f[n][m];
}


```
###分组背包问题
![分组背包](.\photos\分组背包.png "分组背包问题")

```c++
int f[N][N];//f[i][j] 考虑前i组，合计体积不超过 j 的最大价值是 f[i][j]
int s[N],v[N][N],w[N][N];
//s[i]:i组中物品数量 v[i][j]:i组中第j个物品的体积 
//w[i][j]:i组中第j个物品的价值

for(int i=1;i<=n;i++)
        for(int j=m;j>=0;j--)
        {
            f[i][j]=f[i-1][j];//这组一个都不选
            for(int k=0;k<s[i];k++)//选的话 遍历组中每一个
                if(v[i][k]<=j)
                    f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);
        }

```
##线性DP
###数字三角形
![数字三角形](.\photos\数字三角形.png "数字三角形")
###最长上升子序列
![最长上升子序列](.\photos\最长上升子序列.png "最长上升子序列")
###最长公共子序列
![最长公共子序列](.\photos\最长公共子序列.png "最长公共子序列")

> `f[i - 1][j]`和01表示的并不相同，但是01是被包含在其内的。而`f[i - 1][j]`又是被`f[i][j]`包含。所以求`f[i][j]`最大值的时候可以直接使用`f[i - 1][j]`
> `f[i - 1][j - 1]`是被包含在`f[i - 1][j]`和`f[i][j - 1]`当中，所以可以不用计算`f[i - 1][j - 1]`。

##区间dp
![区间dp](.\photos\区间dp.png "区间dp")
![区间dp2](.\photos\区间dp2.png "区间dp")
```c++
for(int len = 2; len <= n; len++)
	for(int i = 1; i + len - 1 <= n; i++){
		int l = i;
		int r = i + len - 1;
		f[l][r] = 1e8;//求最小值时要初始化一个大数。
		for(int k = l; k < r; k++)
			f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
	}
```
##状态压缩
> `<<`表示左移，`1 << n`就表示$2^n$
> 