#动态规划
求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。这就是DP（动态规划，dynamic programming）。将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。
能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
##背包问题
![背包问题](.\photos\背包问题.png "背包问题")
###01背包问题
![01背包问题](.\photos\01背包问题.png "01背包问题")
```c++
for(int i = 1; i <= n; i++ )
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
	}
cout << f[n][m];
```
###完全背包问题
![完全背包](.\photos\完全背包.png "完全背包问题")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0;j <= m; j++)
		for(int k = 0; k *v[i] <=j; k++)
			f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);//包含0在内了,不需要在赋值i-1.
```
![完全背包优化](.\photos\完全背包优化.png "完全背包问题优化")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])
	}
```

如果是算最小值则需要把dp数组全部初始化为最大值。
###多重背包问题
> 多重背包问题就是每件物品的数量是有上限的。
![多重背包](.\photos\多重背包.png "多重背包问题")
> $f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k) k = 0, 1, 2, ..., s[i]$

```c++
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= m; j++)
		for(int k = 0; k * v[i] <= j && k <= s[i]; k++)
			f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
```
> 通过二进制优化可以降低复杂度
> 原理:把一个一个遍历单种物品可以拿的数量转化为一堆一堆的拿,来把遍历数量的复杂度从O(s)降到O(logs)
> 等价于把多重背包拆成了物品变多的01背包
```c++
int n, m;
cin >> n >> m;
int cnt = 0;
for(int i = 1; i <= n; i++){
	int a, b, s;
	cin >> a >> b >> s;
	int k = 1;
	while(k <= s){
		cnt++;
		v[cnt] = k * a;
		w[cnt] = k * b;
		k *= 2;
	}
	if(s > 0){
		cnt++;
		v[cnt] = a * s;
		w[cnt] = b * s;
	}
n = cnt;

for(int i = 1; i <= n; i++)
	for(int j = 0; j <=m; j++){
		f[i][j] = f[i - 1][j];
		f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
	}

cout << f[n][m];
}


```
