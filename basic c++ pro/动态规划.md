#动态规划
求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。这就是DP（动态规划，dynamic programming）。将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。
能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
##背包问题
![背包问题](.\photos\背包问题.png "背包问题")
###01背包问题
![01背包问题](.\photos\01背包问题.png "01背包问题")
```c++
for(int i = 1; i <= n; i++ )
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
	}
cout << f[n][m];
```
###完全背包问题
![完全背包](.\photos\完全背包.png "完全背包问题")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0;j <= m; j++)
		for(int k = 0; k *v[i] <=j; k++)
			f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);//包含0在内了
```
![完全背包优化](.\photos\完全背包优化.png "完全背包问题优化")
```c++
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= m; j++){
		f[i][j] = f[i - 1][j];
		f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])
	}
```

如果是算最小值则需要把dp数组全部初始化为最大值。
