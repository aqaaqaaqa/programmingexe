#数据结构
##链表
###单链表
在实际算法题中使用结构体来构造单链表很费时，所以会使用数组来构建链表。数组模拟链表称为静态链表。
![单链表](.\photos\单链表.png "单链表")
> 二维数组的话一般最多开到1000*1000

####代码
```c++
int head, e[N], ne[N], itx;

void init(void){
	head = -1;
	itx = 0;
}

void inserthead(int x){
	e[itx] = x;
	ne[itx] = head;
	head = itx;
	itx++;
}


void removehead(){
	head = ne[head]
}

```
####p3613
+ 开二维数组一定会爆内存。
+ 从后往前查找可以加快查找速度。
###双链表
![双链表1](.\photos\双链表1.png "双链表1")
![双链表2](.\photos\双链表2.png "双链表2")
####代码
```c++
int e[N], l[N], r[N], itx;

//头节点编号为0，尾节点编号为1。
void init(){
	r[0] = 1;
	l[1] = 0;
	idx = 2;
}
//在a节点后插入一个节点。
void insert(int a, int x){
	e[itx] = x;
	l[itx] = a;
	r[itx] = r[a];
	l[r[a]] = itx;
	r[a] = itx;
	itx ++;
}

void remove(int a){
	r[l[a]] = r[a];
	l[r[a]] = l[a];
}
```
##栈
###普通栈
####代码
```c++
int stk[N], tt;

//插入
stk[++ tt] = x;

//弹出
tt--;

//判断栈是否为空
if(tt > 0) not empty
else empty

//栈顶
stk[tt];
```
###单调栈
![单调栈](.\photos\单调栈.png "单调栈")
+ 让整个栈变成一个单调递增的序列。
+ 假如$a_5 < a_3$ ，那么在$a_5$之后的数在选择时一定就会选择$a_5$而不是$a_3$ ，这样可以完成一个单调递增的栈。
####代码
```c++
//一般用来求数组中一个数的左边离它最近的比它小的数
tt = 0;
for(int i = 0; i < n; i++){
	int x;
	cin >>x;
	while(tt && stk[tt] >= x) tt-- ;
	if(tt) cout << stk[tt] << ' ';
	else cout << -1 << ' ';
	stk[ ++ tt] = x;
}
```
##队列
###普通队列
####代码
```c++
//在队尾插入元素，在队头弹出元素，hh是头指针,尾指针是一直向后移动的，所以尾指针是会大于等于头指针的（如果不空）。
int q[N], hh, tt = -1;

//插入
q[++ tt] = x;

//弹出
hh++

//判断是否为空
if(hh <= tt) not empty
else empty

//队头的值
q[hh];
```
###循环队列
####代码
```c++
//hh表示队头，tt表示队尾后一个位置，tt位置总是可以存
int q[N], hh = 0, tt = 0;

//队尾插入
q[ tt++ ] = x;
if(tt == N) tt = 0;

//队头弹出
hh++;
if(hh == N) hh = 0;

//队头的值
q[hh];

//如果hh != tt则不为空
```
###单调队列
![单调队列](.\photos\单调队列.png "单调队列")
####代码
```c++
int hh = 0, tt = -1;
for(int i = 0; i < n ; i++ ){
	if(tt >= hh && que[hh] >= i - k + 1) hh++;//弹出队头
    while(tt >= hh && a[que[tt]] >= a[i] ) tt--;//弹出队尾
    que[++ tt] = i;//入队
    if(i >= k - 1) cout >> a[que[hh]] >> ' ';//输出
} 
cout >> endl;
```

##KMP
> next数组不能定义为全局变量，在头文件里已经使用过了。

###代码
```c++
int n, m;
int ne[N];
char s[M], p[N];

cin >> n >> p+1 >> m >> s+1; //第一个字符就在S[1], P[1]的位置上。

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度。
// 两个数组的下标都是从1开始。
//求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )//next[1] = 0，所以直接从2开始
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}
//j相当于就是在指示前缀的位置，j在的位置就表示该位置是i之前一位匹配串的最大前缀位置，假如下一位匹配成功了则最大前缀加一，没有匹配成成功则是退回到上一个最大前缀的位置看看上一个的

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];//j从0开始可以让j = ne[j]而不是j = ne[j - 1]
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}

for(int i = 1, j = 0 ; i <= n; i++){
	while(j && p[j + 1] != s[j]) j = ne[j];
	if(p[j + 1] == s[j]) j++;
	if(j == m){
		j = ne[j];
		//
	}
	
}
```

## Trie树

> 高效的存储和查找字符串的数据结构。
> Trie树本质，利用字符串之间的公共前缀，将重复的前缀合并在一起。

![trie树](.\photos\trie树.png "trie树")
###代码
```c++
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;//idx是看看它下一个字母应该存到第几层去。
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}



int tree[100010][26], idx, con[100010];
string a;

void insert(string a){
	q = 0;
	for(int i = 0; a[i]; i++){
		int b = a[i] - 'a';
		if(tree[q][b] != 0) q = tree[q][b];
		else tree[q][b] = ++ idx;
	}
	cnt[q] ++;
}

int query(string a){
	q = 0;
	for(int i = 0; a[i]; i++){
		int b = a[i] - 'a';
		if(tree[q][b] != 0) q = tree[q][b];
		else return 0;
	}
	return con[q];
}
```

##并查集
> 1. 将两个集合合并。
> 2. 询问两个元素是否在一个集合当中。
> 初始的时候每个点都是一个集合。
> 基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。
> 如何判断树根`if(p[x] == x)`。
> 如何求x的集合编号：`while(p[x] != x) x = p[x];`
> 如何合并两个集合：p[x]是x的集合编号，p[y]是y的集合编号。p[x] = y。
> 按秩合并：在执行合并操作时，将更小的树连接到更大的树上。（优化的很少）
> 路径压缩：在查找集合序号时将整条路径上的点都设为树的根节点。`while(p[x] != x) p[x] = find(p[x])`

###代码
```c++
int find(int x){//查找树的根节点并且路径压缩。
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}
//可以多维护一个数组表示每个集合的点数量。
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量。
// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);

//d[x]存储x到p[x]的距离。
 int find(int x){
        if (p[x] != x){
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
    
//循环版find 
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    //让x和x的父亲变成他的父亲的父亲
    //直到找到祖先才结束循环(x==fa[x])就意味着找到爹了
    return x;
}
```